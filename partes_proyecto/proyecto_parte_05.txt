PARTE: 05
PROYECTO: SIGEA_DSI
FECHA: 2025-11-11 09:49:28
CARPETAS EXCLUIDAS: bootstrap, jquery, fontawesome, etc.
================================================================================


============================================================
ARCHIVO: app\modules\importacion\routes.py
============================================================

# app/modules/importacion/routes.py
from flask import render_template, request, jsonify, flash, redirect, url_for, send_file
from flask_login import login_required, current_user
import pandas as pd
import io
from datetime import datetime
from . import importacion_bp
from app.models import Estudiante, Curso, Inscripcion, Evaluacion, Nota, SeguimientoRiesgo
from app.extensions import db

@importacion_bp.route('/')
@login_required
def index():
    """Panel de importación de datos"""
    return render_template('importacion/index.html')

@importacion_bp.route('/importar-estudiantes', methods=['POST'])
@login_required
def importar_estudiantes():
    """Importar estudiantes desde archivo Excel/CSV"""
    try:
        if 'archivo' not in request.files:
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        # Leer archivo
        if archivo.filename.endswith('.csv'):
            df = pd.read_csv(archivo)
        else:
            df = pd.read_excel(archivo)
        
        # Validar columnas requeridas
        columnas_requeridas = ['codigo_estudiante', 'nombres', 'apellidos', 'email']
        for columna in columnas_requeridas:
            if columna not in df.columns:
                flash(f'Columna requerida faltante: {columna}', 'danger')
                return redirect(url_for('importacion.index'))
        
        estudiantes_importados = 0
        estudiantes_actualizados = 0
        
        for _, fila in df.iterrows():
            # Buscar si el estudiante ya existe
            estudiante = Estudiante.query.filter_by(
                codigo_estudiante=fila['codigo_estudiante']
            ).first()
            
            if estudiante:
                # Actualizar estudiante existente
                estudiante.nombres = fila['nombres']
                estudiante.apellidos = fila['apellidos']
                estudiante.email = fila['email']
                estudiante.telefono = fila.get('telefono', '')
                estudiantes_actualizados += 1
            else:
                # Crear nuevo estudiante
                estudiante = Estudiante(
                    codigo_estudiante=fila['codigo_estudiante'],
                    nombres=fila['nombres'],
                    apellidos=fila['apellidos'],
                    email=fila['email'],
                    telefono=fila.get('telefono', ''),
                    activo=True
                )
                db.session.add(estudiante)
                estudiantes_importados += 1
        
        db.session.commit()
        
        flash(f'✅ Importación exitosa: {estudiantes_importados} nuevos, {estudiantes_actualizados} actualizados', 'success')
        return redirect(url_for('importacion.resultados'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'❌ Error en importación: {str(e)}', 'danger')
        return redirect(url_for('importacion.index'))

@importacion_bp.route('/importar-cursos', methods=['POST'])
@login_required
def importar_cursos():
    """Importar cursos desde archivo Excel/CSV"""
    try:
        if 'archivo' not in request.files:
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        # Leer archivo
        if archivo.filename.endswith('.csv'):
            df = pd.read_csv(archivo)
        else:
            df = pd.read_excel(archivo)
        
        # Validar columnas requeridas
        columnas_requeridas = ['codigo_curso', 'nombre_curso', 'semestre']
        for columna in columnas_requeridas:
            if columna not in df.columns:
                flash(f'Columna requerida faltante: {columna}', 'danger')
                return redirect(url_for('importacion.index'))
        
        cursos_importados = 0
        cursos_actualizados = 0
        
        for _, fila in df.iterrows():
            # Buscar si el curso ya existe
            curso = Curso.query.filter_by(
                codigo_curso=fila['codigo_curso'],
                semestre=fila['semestre']
            ).first()
            
            if curso:
                # Actualizar curso existente
                curso.nombre_curso = fila['nombre_curso']
                curso.creditos = fila.get('creditos', 3)
                cursos_actualizados += 1
            else:
                # Crear nuevo curso
                curso = Curso(
                    codigo_curso=fila['codigo_curso'],
                    nombre_curso=fila['nombre_curso'],
                    creditos=fila.get('creditos', 3),
                    semestre=fila['semestre'],
                    activo=True
                )
                db.session.add(curso)
                cursos_importados += 1
        
        db.session.commit()
        
        flash(f'✅ Cursos importados: {cursos_importados} nuevos, {cursos_actualizados} actualizados', 'success')
        return redirect(url_for('importacion.resultados'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'❌ Error en importación: {str(e)}', 'danger')
        return redirect(url_for('importacion.index'))

@importacion_bp.route('/importar-notas', methods=['POST'])
@login_required
def importar_notas():
    """Importar notas desde archivo Excel/CSV"""
    try:
        if 'archivo' not in request.files:
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            flash('No se seleccionó ningún archivo', 'danger')
            return redirect(url_for('importacion.index'))
        
        # Leer archivo
        if archivo.filename.endswith('.csv'):
            df = pd.read_csv(archivo)
        else:
            df = pd.read_excel(archivo)
        
        # Validar columnas requeridas
        columnas_requeridas = ['codigo_estudiante', 'codigo_curso', 'nombre_evaluacion', 'nota']
        for columna in columnas_requeridas:
            if columna not in df.columns:
                flash(f'Columna requerida faltante: {columna}', 'danger')
                return redirect(url_for('importacion.index'))
        
        notas_importadas = 0
        
        for _, fila in df.iterrows():
            # Buscar estudiante y curso
            estudiante = Estudiante.query.filter_by(
                codigo_estudiante=fila['codigo_estudiante']
            ).first()
            
            curso = Curso.query.filter_by(
                codigo_curso=fila['codigo_curso']
            ).first()
            
            if not estudiante or not curso:
                continue  # Saltar si no encuentra estudiante o curso
            
            # Buscar o crear inscripción
            inscripcion = Inscripcion.query.filter_by(
                estudiante_id=estudiante.id,
                curso_id=curso.id
            ).first()
            
            if not inscripcion:
                inscripcion = Inscripcion(
                    estudiante_id=estudiante.id,
                    curso_id=curso.id,
                    estado='ACTIVO'
                )
                db.session.add(inscripcion)
                db.session.flush()  # Para obtener el ID
            
            # Buscar o crear evaluación
            evaluacion = Evaluacion.query.filter_by(
                curso_id=curso.id,
                nombre_evaluacion=fila['nombre_evaluacion']
            ).first()
            
            if not evaluacion:
                evaluacion = Evaluacion(
                    curso_id=curso.id,
                    nombre_evaluacion=fila['nombre_evaluacion'],
                    tipo_evaluacion='PARCIAL',
                    peso=100.0
                )
                db.session.add(evaluacion)
                db.session.flush()
            
            # Buscar o crear nota
            nota = Nota.query.filter_by(
                inscripcion_id=inscripcion.id,
                evaluacion_id=evaluacion.id
            ).first()
            
            if nota:
                # Actualizar nota existente
                nota.nota = float(fila['nota'])
            else:
                # Crear nueva nota
                nota = Nota(
                    inscripcion_id=inscripcion.id,
                    evaluacion_id=evaluacion.id,
                    nota=float(fila['nota']),
                    fecha_registro=pd.to_datetime(fila.get('fecha', datetime.utcnow()))
                )
                db.session.add(nota)
            
            notas_importadas += 1
        
        db.session.commit()
        
        flash(f'✅ Notas importadas: {notas_importadas} registros procesados', 'success')
        return redirect(url_for('importacion.resultados'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'❌ Error en importación: {str(e)}', 'danger')
        return redirect(url_for('importacion.index'))

@importacion_bp.route('/resultados')
@login_required
def resultados():
    """Mostrar resultados de importaciones"""
    # Obtener estadísticas actuales
    estadisticas = {
        'estudiantes': Estudiante.query.filter_by(activo=True).count(),
        'cursos': Curso.query.filter_by(activo=True).count(),
        'notas': Nota.query.count(),
        'riesgo': SeguimientoRiesgo.query.filter(
            SeguimientoRiesgo.categoria_riesgo != 'SIN_RIESGO'
        ).count()
    }
    
    return render_template('importacion/resultados.html', estadisticas=estadisticas)

@importacion_bp.route('/descargar-plantilla/<tipo>')
@login_required
def descargar_plantilla(tipo):
    """Descargar plantillas para importación"""
    if tipo == 'estudiantes':
        # Crear DataFrame de ejemplo para estudiantes
        df = pd.DataFrame({
            'codigo_estudiante': ['2024EST001', '2024EST002'],
            'nombres': ['Juan Carlos', 'María Elena'],
            'apellidos': ['García López', 'Rodríguez Martínez'],
            'email': ['juan.garcia@ejemplo.com', 'maria.rodriguez@ejemplo.com'],
            'telefono': ['123456789', '987654321']
        })
    elif tipo == 'cursos':
        df = pd.DataFrame({
            'codigo_curso': ['MAT101', 'PROG102'],
            'nombre_curso': ['Matemáticas Básicas', 'Programación Python'],
            'creditos': [4, 3],
            'semestre': ['2024-1', '2024-1']
        })
    elif tipo == 'notas':
        df = pd.DataFrame({
            'codigo_estudiante': ['2024EST001', '2024EST001'],
            'codigo_curso': ['MAT101', 'MAT101'],
            'nombre_evaluacion': ['Parcial 1', 'Parcial 2'],
            'nota': [15.5, 14.0],
            'fecha': ['2024-03-15', '2024-04-20']
        })
    else:
        flash('Tipo de plantilla no válido', 'danger')
        return redirect(url_for('importacion.index'))
    
    # Crear archivo en memoria
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, sheet_name='Plantilla', index=False)
    output.seek(0)
    
    return send_file(
        output,
        download_name=f'plantilla_{tipo}.xlsx',
        as_attachment=True,
        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )


============================================================
ARCHIVO: app\modules\importacion\__init__.py
============================================================

# app/modules/importacion/__init__.py
from flask import Blueprint

importacion_bp = Blueprint('importacion', __name__, url_prefix='/importacion')

from . import routes


============================================================
ARCHIVO: app\modules\inscripciones\forms.py
============================================================

# app/modules/inscripciones/forms.py
from flask_wtf import FlaskForm
from wtforms import SelectField, DateField, StringField, SubmitField
from wtforms.validators import DataRequired, Optional,length
from app.models import Estudiante, Curso

class InscripcionForm(FlaskForm):
    estudiante_id = SelectField('Estudiante', coerce=int, validators=[DataRequired()])
    curso_id = SelectField('Curso', coerce=int, validators=[DataRequired()])
    fecha_inscripcion = DateField('Fecha de Inscripción', validators=[DataRequired()])
    estado = SelectField('Estado', 
                        choices=[
                            ('ACTIVO', 'Activo'),
                            ('INACTIVO', 'Inactivo'), 
                            ('RETIRADO', 'Retirado'),
                            ('APROBADO', 'Aprobado'),
                            ('REPROBADO', 'Reprobado')
                        ],
                        validators=[DataRequired()])
    submit = SubmitField('Guardar Inscripción')
    
    def __init__(self, *args, **kwargs):
        super(InscripcionForm, self).__init__(*args, **kwargs)
        # Cargar estudiantes activos
        self.estudiante_id.choices = [
            (est.id, f"{est.codigo_estudiante} - {est.nombres} {est.apellidos}")
            for est in Estudiante.query.filter_by(activo=True).order_by('apellidos').all()
        ]
        # Cargar cursos activos
        self.curso_id.choices = [
            (curso.id, f"{curso.codigo_curso} - {curso.nombre_curso} ({curso.semestre})")
            for curso in Curso.query.filter_by(activo=True).order_by('semestre', 'nombre_curso').all()
        ]
        
# ------------------------------------------------------------------
# MATRICULAS MASIVAS    
# app/modules/inscripciones/forms.py - AÑADIR
class MatriculaMasivaForm(FlaskForm):
    semestre = SelectField('Semestre', coerce=str, validators=[DataRequired()])
    grupo_estudiantes = SelectField('Grupo de Estudiantes', 
        choices=[
            ('todos', 'Todos los estudiantes activos'),
            ('nuevos', 'Solo estudiantes nuevos en el semestre')
        ], validators=[DataRequired()])
    fecha_inscripcion = DateField('Fecha de Matrícula', validators=[DataRequired()])
    estado = SelectField('Estado Inicial',
        choices=[
            ('ACTIVO', 'Activo'),
            ('OBSERVADO', 'Observado')
        ], default='ACTIVO')
    submit = SubmitField('Generar Matrícula Masiva')
    
    def __init__(self, *args, **kwargs):
        super(MatriculaMasivaForm, self).__init__(*args, **kwargs)
        # Importar la aplicación para acceder a la BD
        from flask import current_app
        from app.models import Curso
        
        with current_app.app_context():
            try:
                from app.extensions import db
                semestres = db.session.query(Curso.semestre)\
                    .filter(Curso.activo == True)\
                    .distinct()\
                    .order_by(Curso.semestre)\
                    .all()
                
                self.semestre.choices = [(sem[0], f'Semestre {sem[0]}') for sem in semestres]
                
                if not self.semestre.choices:
                    self.semestre.choices = [('', 'No hay cursos activos')]
                    
            except Exception as e:
                print(f"Error cargando semestres: {e}")
                # Fallback a semestres por defecto
                self.semestre.choices = [
                    ('I', 'Semestre I'), ('II', 'Semestre II'), ('III', 'Semestre III'),
                    ('IV', 'Semestre IV'), ('V', 'Semestre V'), ('VI', 'Semestre VI')
                ]


============================================================
ARCHIVO: app\modules\inscripciones\routes.py
============================================================

# app/modules/inscripciones/routes.py
from flask import render_template, request, jsonify, flash, redirect, url_for
from flask_login import login_required, current_user
from . import inscripciones_bp
from app.models import Inscripcion, Estudiante, Curso, Asistencia, Nota, Evaluacion
from app.extensions import db
from .forms import InscripcionForm
from datetime import datetime
from .forms import InscripcionForm, MatriculaMasivaForm 


# PARA MATRICULAR DE UNA SOLA VEZ EN UN CICLO
@inscripciones_bp.route('/matricula-masiva', methods=['GET', 'POST'])
@login_required
def matricula_masiva():
    """Matrícula masiva de estudiantes a todos los cursos de un semestre"""
    
    form = MatriculaMasivaForm()
    
    if form.validate_on_submit():
        try:
            # ✅ CORREGIDO: usar semestre en lugar de ciclo_id
            semestre = form.semestre.data
            grupo = form.grupo_estudiantes.data
            fecha_inscripcion = form.fecha_inscripcion.data
            estado = form.estado.data
            
            # ✅ CORREGIDO: buscar por semestre
            cursos_semestre = Curso.query.filter_by(semestre=semestre, activo=True).all()
            
            if not cursos_semestre:
                flash(f'No hay cursos activos para el semestre {semestre}', 'warning')
                return render_template('inscripciones/matricula_masiva.html', form=form)
            
            # Obtener estudiantes según criterio
            if grupo == 'todos':
                estudiantes = Estudiante.query.filter_by(activo=True).all()
            else:  # 'nuevos'
                # Estudiantes sin inscripciones en el semestre
                estudiantes_subquery = db.session.query(Inscripcion.estudiante_id)\
                    .join(Curso).filter(Curso.semestre == semestre).subquery()
                estudiantes = Estudiante.query.filter(
                    Estudiante.activo == True,
                    ~Estudiante.id.in_(estudiantes_subquery)
                ).all()
            
            if not estudiantes:
                flash('No hay estudiantes que cumplan con el criterio seleccionado', 'warning')
                return render_template('inscripciones/matricula_masiva.html', form=form)
            
            # Procesar matrícula masiva
            matriculas_creadas = 0
            matriculas_actualizadas = 0
            
            for estudiante in estudiantes:
                for curso in cursos_semestre:
                    # Verificar si ya existe la inscripción
                    inscripcion_existente = Inscripcion.query.filter_by(
                        estudiante_id=estudiante.id,
                        curso_id=curso.id
                    ).first()
                    
                    if inscripcion_existente:
                        # Actualizar estado si existe
                        inscripcion_existente.estado = estado
                        inscripcion_existente.fecha_inscripcion = fecha_inscripcion
                        matriculas_actualizadas += 1
                    else:
                        # Crear nueva inscripción
                        nueva_inscripcion = Inscripcion(
                            estudiante_id=estudiante.id,
                            curso_id=curso.id,
                            fecha_inscripcion=fecha_inscripcion,
                            estado=estado
                        )
                        db.session.add(nueva_inscripcion)
                        matriculas_creadas += 1
            
            db.session.commit()
            
            flash(
                f'✅ Matrícula masiva completada: '
                f'{matriculas_creadas} nuevas inscripciones, '
                f'{matriculas_actualizadas} actualizadas. '
                f'({len(estudiantes)} estudiantes × {len(cursos_semestre)} cursos)',
                'success'
            )
            return redirect(url_for('inscripciones.index'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'❌ Error en matrícula masiva: {str(e)}', 'danger')
    
    # Para GET request, establecer fecha actual como default
    if request.method == 'GET':
        form.fecha_inscripcion.data = datetime.utcnow().date()
    
    return render_template('inscripciones/matricula_masiva.html', form=form)





@inscripciones_bp.route('/')
@login_required
def index():
    """Lista de todas las inscripciones"""
    page = request.args.get('page', 1, type=int)
    per_page = 10

    # Query base con joins para estudiante y curso
    inscripciones_query = Inscripcion.query.join(Estudiante).join(Curso)

    # Búsqueda
    search = request.args.get('search', '')
    if search:
        inscripciones_query = inscripciones_query.filter(
            db.or_(
                Estudiante.nombres.ilike(f'%{search}%'),
                Estudiante.apellidos.ilike(f'%{search}%'),
                Estudiante.codigo_estudiante.ilike(f'%{search}%'),
                Curso.nombre_curso.ilike(f'%{search}%'),
                Curso.codigo_curso.ilike(f'%{search}%')
            )
        )

    # Filtros
    estudiante_id = request.args.get('estudiante_id', type=int)
    curso_id = request.args.get('curso_id', type=int)
    estado = request.args.get('estado', '')
    
    if estudiante_id:
        inscripciones_query = inscripciones_query.filter(Inscripcion.estudiante_id == estudiante_id)
    if curso_id:
        inscripciones_query = inscripciones_query.filter(Inscripcion.curso_id == curso_id)
    if estado:
        inscripciones_query = inscripciones_query.filter(Inscripcion.estado == estado)

    inscripciones = inscripciones_query.order_by(
        Inscripcion.fecha_inscripcion.desc()
    ).paginate(page=page, per_page=per_page, error_out=False)

    # Para los filtros
    estudiantes = Estudiante.query.filter_by(activo=True).order_by('apellidos').all()
    cursos = Curso.query.filter_by(activo=True).order_by('semestre', 'nombre_curso').all()

    return render_template('inscripciones/index.html',
                         inscripciones=inscripciones,
                         estudiantes=estudiantes,
                         cursos=cursos,
                         search=search,
                         estudiante_id=estudiante_id,
                         curso_id=curso_id,
                         estado=estado)

@inscripciones_bp.route('/crear', methods=['GET', 'POST'])
@login_required
def crear():
    """Crear nueva inscripción"""
    form = InscripcionForm()
    
    if form.validate_on_submit():
        try:
            # Verificar si ya existe la inscripción
            inscripcion_existente = Inscripcion.query.filter_by(
                estudiante_id=form.estudiante_id.data,
                curso_id=form.curso_id.data
            ).first()
            
            if inscripcion_existente:
                flash('El estudiante ya está inscrito en este curso', 'danger')
                return render_template('inscripciones/crear.html', form=form)
            
            # Crear nueva inscripción
            nueva_inscripcion = Inscripcion(
                estudiante_id=form.estudiante_id.data,
                curso_id=form.curso_id.data,
                fecha_inscripcion=form.fecha_inscripcion.data,
                estado=form.estado.data
            )
            
            db.session.add(nueva_inscripcion)
            db.session.commit()
            
            flash('Inscripción creada exitosamente', 'success')
            return redirect(url_for('inscripciones.index'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error al crear inscripción: {str(e)}', 'danger')
    
    # Para GET request, establecer fecha actual como default
    if request.method == 'GET':
        form.fecha_inscripcion.data = datetime.utcnow().date()
        form.estado.data = 'ACTIVO'
    
    return render_template('inscripciones/crear.html', form=form)



@inscripciones_bp.route('/<int:inscripcion_id>')
@login_required
def detalle(inscripcion_id):
    """Detalle de una inscripción específica"""
    inscripcion = Inscripcion.query.get_or_404(inscripcion_id)
    
    # Obtener asistencias
    asistencias = (
        Asistencia.query
        .filter_by(inscripcion_id=inscripcion_id)
        .order_by(Asistencia.fecha.desc())
        .all()
    )
    
    # Obtener notas con join correcto
    notas = (
        Nota.query
        .filter_by(inscripcion_id=inscripcion_id)
        .join(Nota.evaluacion)
        .order_by(Evaluacion.nombre_evaluacion)
        .all()
    )
    
    # Calcular estadísticas
    total_asistencias = len(asistencias)
    asistencias_presente = sum(1 for a in asistencias if a.presente)
    porcentaje_asistencia = (asistencias_presente / total_asistencias * 100) if total_asistencias > 0 else 0
    
    promedio_notas = (
        db.session.query(db.func.avg(Nota.nota))
        .filter_by(inscripcion_id=inscripcion_id)
        .scalar()
        or 0
    )

    return render_template(
        'inscripciones/detalle.html',
        inscripcion=inscripcion,
        asistencias=asistencias,
        notas=notas,
        total_asistencias=total_asistencias,
        asistencias_presente=asistencias_presente,
        porcentaje_asistencia=porcentaje_asistencia,
        promedio_notas=promedio_notas
    )



@inscripciones_bp.route('/<int:inscripcion_id>/editar', methods=['GET', 'POST'])
@login_required
def editar(inscripcion_id):
    """Editar inscripción existente"""
    inscripcion = Inscripcion.query.get_or_404(inscripcion_id)
    form = InscripcionForm(obj=inscripcion)
    
    if form.validate_on_submit():
        try:
            # Verificar si ya existe la inscripción (excluyendo la actual)
            inscripcion_existente = Inscripcion.query.filter(
                Inscripcion.estudiante_id == form.estudiante_id.data,
                Inscripcion.curso_id == form.curso_id.data,
                Inscripcion.id != inscripcion_id
            ).first()
            
            if inscripcion_existente:
                flash('El estudiante ya está inscrito en este curso', 'danger')
                return render_template('inscripciones/editar.html', form=form, inscripcion=inscripcion)
            
            # Actualizar inscripción
            inscripcion.estudiante_id = form.estudiante_id.data
            inscripcion.curso_id = form.curso_id.data
            inscripcion.fecha_inscripcion = form.fecha_inscripcion.data
            inscripcion.estado = form.estado.data
            
            db.session.commit()
            
            flash('Inscripción actualizada exitosamente', 'success')
            return redirect(url_for('inscripciones.detalle', inscripcion_id=inscripcion.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error al actualizar inscripción: {str(e)}', 'danger')
    
    return render_template('inscripciones/editar.html', form=form, inscripcion=inscripcion)

@inscripciones_bp.route('/<int:inscripcion_id>/eliminar', methods=['POST'])
@login_required
def eliminar(inscripcion_id):
    """Eliminar inscripción"""
    try:
        inscripcion = Inscripcion.query.get_or_404(inscripcion_id)
        
        # Verificar si tiene registros relacionados
        if inscripcion.asistencias:
            flash('No se puede eliminar la inscripción porque tiene asistencias relacionadas', 'danger')
            return redirect(url_for('inscripciones.detalle', inscripcion_id=inscripcion_id))
        
        if inscripcion.notas:
            flash('No se puede eliminar la inscripción porque tiene notas relacionadas', 'danger')
            return redirect(url_for('inscripciones.detalle', inscripcion_id=inscripcion_id))
        
        db.session.delete(inscripcion)
        db.session.commit()
        
        flash('Inscripción eliminada exitosamente', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error al eliminar inscripción: {str(e)}', 'danger')
    
    return redirect(url_for('inscripciones.index'))




============================================================
ARCHIVO: app\modules\inscripciones\__init__.py
============================================================

# app/modules/inscripciones/__init__.py
from flask import Blueprint

inscripciones_bp = Blueprint('inscripciones', __name__, url_prefix='/inscripciones')

from . import routes
from . import forms


============================================================
ARCHIVO: app\modules\main\routes.py
============================================================

# app/modules/main/routes.py
from flask import redirect, url_for
from . import main_bp

@main_bp.route('/')
def index():
    """Ruta raíz principal - redirige al login"""
    return redirect(url_for('auth.login'))


============================================================
ARCHIVO: app\modules\main\__init__.py
============================================================

from flask import Blueprint

main_bp = Blueprint(
    'main',
    __name__,
    template_folder='templates',
    static_folder='static',
    static_url_path='/main/static'
)

from . import routes  # Importa rutas para que queden registradas



============================================================
ARCHIVO: app\modules\main\static\main\main.css
============================================================

body {
    background-color: #f4f4f4;
}

h1 {
    color: #333;
}


